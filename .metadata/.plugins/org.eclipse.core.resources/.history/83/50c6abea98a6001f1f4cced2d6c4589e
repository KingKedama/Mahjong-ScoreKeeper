/*
Copyright 2004 Steve Jolly

This file is part of Pony

Pony is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; specifically version 2 of the License.

Pony is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Pony; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

import org.jibble.pircbot.*;

import java.util.Collections;
import java.util.HashMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.File;
import java.math.*;

import javax.swing.plaf.basic.BasicBorders.SplitPaneBorder;

//TODO remove the useless code
public class MahjongBot extends PircBot
{

	public String ServerName;
	public int ServerPort;
	public String ServerPassword;
	public String BotName;
	public IrcConsole con;
	public String channel;
	public HashMap<String, String> allowed;// (hostname,login)
	public HashMap<String, String> whoisref;
	public String DelayedCommand;
	public String DelComsender;
	public static String PERMISSION = "alrightfellow";
	// stuff for ircgame
	public static int TIMEOUT=120000;//two minutes
	public String game;
	public Vector<String[]> player;// by hostmask||nick
	public Vector<Tile>[] hands;
	public Vector<Tile>[] discarded;
	public String[] discards;
	public Tile last;
	public int lastdiscarder;
	public Vector<Meld>[] open;
	public int lastchi;
	public Tile[] lastdrawn;
	public Vector<Tile> wall;
	public Vector<Tile> dead;
	public Vector<Tile> dora;// indicators

	public MahjongBot(String CServerName, int CServerPort, String CServerPassword, String CBotName, IrcConsole c, String chan)
	{
		ServerName = CServerName;
		ServerPort = CServerPort;
		ServerPassword = CServerPassword;
		BotName = CBotName;
		this.setName(BotName);
		this.setLogin("KedamaBotsInc");
		con = c;
		channel = chan;
		c.SetBot(this);
		allowed = new HashMap<String, String>();
		whoisref = new HashMap<String, String>();
	}

	public void updateops(String chan)
	{
		User[] users = this.getUsers(chan);
		System.out.println(users.length);
		allowed.clear();
		for (User u : users)
		{

			if (u.getNick().contains("%") || u.getNick().contains("~"))
			{
				if (u.getNick().substring(1).equalsIgnoreCase(this.DelComsender))
				{
					this.onmess(this.DelComsender, PERMISSION, this.DelayedCommand);
				}
				whoisref.put(u.getNick().toLowerCase().substring(1), chan);
				sendRawLineViaQueue("WHOIS " + u.getNick().substring(1));
			}
		}
		DelComsender = null;
	}

	protected void onServerResponse(int code, String response)
	{

		if (code == RPL_WHOISUSER)
		{
			String parts[] = response.split(" ");
			String user = parts[1].toLowerCase();
			if (whoisref.containsKey(user))
			{ // nick
				String target = (String) whoisref.get(user);
				allowed.put(parts[2] + parts[3], "");
				whoisref.remove(user);
			}
		}
		
	}

	protected void onOp(String channel, String sourceNick, String sourceLogin, String sourceHostname, String recipient)
	{

		whoisref.put(recipient.toLowerCase(), channel);
		sendRawLineViaQueue("WHOIS " + recipient);
	}

	public void onMessage(String channel, String sender, String login, String hostname, String mess)
	{
		this.channel = channel;
		onmess(sender, login + hostname, mess);
	}

	public void onmess(String sendera, String hostmask, String message)
	{
		String sender=sendera;
		String mess=message.toLowerCase();
		Pattern p=Pattern.compile("(\\w)\\1+");
		Matcher m=p.matcher(mess);
		StringBuffer sb=new StringBuffer();
		while(m.find())
		{
			m.appendReplacement(sb,""+ m.group(0).charAt(0));
		}
		m.appendTail(sb);
		mess=sb.toString();
		
		boolean permission = allowed.containsKey(hostmask) || hostmask.equalsIgnoreCase(PERMISSION);
		if (mess.indexOf('!') == 0)
		{
			if (mess.substring(1).equalsIgnoreCase("test tiles"))
			{
				String tiles = "";
				for (Tile t : Tile.test)
				{
					tiles = tiles + t.display + " ";
				}
				this.sendMessage(channel, tiles);
			}
			else if (mess.substring(1).indexOf("ircgame") == 0)
				ircgame(message, sender, hostmask);
			else if (mess.indexOf("join") == 1)
				join(sender, hostmask);
			else if (mess.indexOf("end") == 1)
			{
				if (game != null)
				{
					con.endgame(new String[]
					{ "", game });
					game = null;
					player = null;
				}
				else if (permission)
					con.parseCommand(mess.substring(1), true);

			}
			else if (mess.indexOf("hand") == 1)// TODO add command to see open
												// parts of other hands
				printhand(sender, hostmask);
			else if (mess.indexOf("draw") == 1)
				drawtile(sender, hostmask);
			else if (mess.indexOf("discard") == 1)
				discard(sender, hostmask, mess.substring(8).trim());
			else if (mess.indexOf("pon") == 1)
				pon(sender, hostmask);
			else if (mess.indexOf("dora") == 1)
				printdora();
			else if (mess.indexOf("nexthand") == 1)
				nexthand();
			else if (mess.indexOf("chi") == 1)
				chi(sender, hostmask, mess.substring(4).trim());
			else if (mess.indexOf("reveal") == 1)
				revealhand(sender, hostmask);
			else if (mess.indexOf("kan")==1 || mess.indexOf("khan")==1)
				kan(sender,hostmask,mess.substring(4).trim());
			else if(mess.indexOf("uradora")==1)
				uradora();
			else if(mess.indexOf("bird")==1)
				dccSendFile(new File("bird.ttf"),sender,TIMEOUT);
			else if (permission)
			{
				con.parseCommand(message.substring(1), true);
			}
			else
			{
				this.DelayedCommand = mess;
				this.DelComsender = sender;
				updateops(channel);

			}
		}
	}

	public void onPrivateMessage(String sender, String login, String hostname, String mess)
	{
		onmess(sender, login + hostname, mess);

	}

	public void onAction(String sender, String login, String hostname, String target, String action)
	{

	}

	protected void onDisconnect()
	{
		int tries = 0;
		while (tries < 1000 && !isConnected())
		{
			try
			{
				connect(ServerName, ServerPort, ServerPassword);
			} catch (Exception e)
			{
				this.log("Connection attempt " + tries + " failed.");
				tries++;
				if (tries >= 1000000)
					System.exit(0);
			}
		} // while
	}

	protected void onKick(String channel, String kickerNick, String kickerLogin, String kickerHostname, String recipientNick, String reason)
	{
		if (recipientNick.equals(BotName))
		{
			joinChannel(channel);
		}
	}

	// irc game methods
	public void ircgame(String mess, String sender, String hostmask)
	{
		if (game != null)
		{
			sendMessage(channel, "there is already an irc game in progress, type !end " + game + " to end it");
			return;
		}
		if (mess.split(" ").length != 2)
		{
			// TODO error
			return;
		}
		if (con.games.containsKey(mess.split(" ")[1]))
		{
			// TODO error
			return;
		}
		game = mess.split(" ")[1];
		player = new Vector<String[]>();
		newhand();
		join(sender, hostmask);
	}

	public void join(String sender, String hostmask)
	{
		if (game == null)
		{
			// TODO start game first
			return;
		}
		if (player.size() >= 4)
		{
			// TODO no room
			return;
		}
		for (String[] s : player)
			if (s[1].equalsIgnoreCase(hostmask))
			{
				// TODO already in
				return;
			}

		player.add(new String[]
		{ sender.toLowerCase(), hostmask ,sender});
		sendMessage(channel, sender + " has joined the game");
		if (player.size() == 4)
		{
			String[] split = new String[6];
			split[1] = game;
			int i = 2;
			Collections.shuffle(player);
			for (String[] s : player)
			{
				printhand(s[0], s[1]);
				printhand(s[0], s[1]);
				split[i] = s[2];
				i++;
			}
			con.freegame(split, "");
			printdora();
		}
	}

	public void printhand(String sender, String hostmask)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			sendMessage(channel, sender + ", you do not have a hand");
			return;
		}
		String hand = hands[index].elementAt(0).display;
		for (int i = 1; i < hands[index].size(); i++)
			hand = hand + " " + hands[index].elementAt(i).display;
		sendNotice(sender, hand);
		if (open[index].size() > 0)
		{
			String s = "";
			for (Meld m : open[index])
			{
				s = s + " " + m.taken.taken() + Colors.NORMAL + " ";
				for (Tile t : m.other)
					s = s + t.display + " ";
				s = s + " ";
			}
			sendMessage(channel, sender + "'s open:" + s);
		}
		Tile.sortHand(hands[index]);// TODO possibly to a simpler find place for
									// new tile here
	}

	public int playerindex(String sender, String hostmask)
	{
		for (int i = 0; i < player.size(); i++)
		{
			if (player.elementAt(i)[1].equalsIgnoreCase(hostmask))
			{
				return i;

			}
			else if (player.elementAt(i)[0].equalsIgnoreCase(sender))
			{
				player.elementAt(i)[1] = hostmask;
				return i;
				// TODO make this more secure, only hostmask maybe? find out if
				// they're registered? sender still necessary for sendNotice
			}
		}
		return -1;
	}

	public void drawtile(String sender, String hostmask)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			// TODO not in this game
			return;
		}
		Tile t=wall.remove(0);
		hands[index].add(t);
		lastdrawn[index]=t;
		printhand(sender, hostmask);
		sendMessage(channel, wall.size() + " tiles left in the wall");
	}

	public void discard(String sender, String hostmask, String tile)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			// TODO not in this game
			return;
		}
		Tile t = Tile.lookup(tile.toLowerCase());
		if (t == null)
		{
			sendMessage(channel, tile + " is not a valid representation for a tile");
			return;
		}
		if (!hands[index].contains(t))
		{
			sendMessage(channel, sender + ", you do not have a " + t.display + " in your hand");
			return;
		}
		lastchi = -1;
		hands[index].remove(t);// TODO add to discards and print them
		discarded[index].add(t);
		discards[index] += t.display + " ";
		last = t;
		lastdiscarder = index;
		printhand(sender, hostmask);
		if(t==lastdrawn[index])
			sendMessage(channel,sender+"discarded the "+t.display+" that they drew");
		else
			sendMessage(channel,sender+"discarded a "+t.display+" from their hand");
		sendMessage(channel, sender + " discards:" + discards[index]);
		sendMessage(channel, player.elementAt((index + 1) % 4)[0] + " is next");

	}

	public void pon(String sender, String hostmask)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			// TODO not in this game
			return;
		}
		int count = 0;
		for (Tile t : hands[index])
			if (t.equals(last))
				count++;
		if (count < 2)
		{
			sendMessage(channel, sender + ", you cannot pon a " + last.display);
			return;
		}
		open[index].add(new Meld(last, new Tile[]
		{ last, last }));
		hands[index].remove(last);
		hands[index].remove(last);
		last = null;
		String[] dis = discards[lastdiscarder].split(" ");
		discards[lastdiscarder] = "";
		for (int i = 0; i < dis.length - 1; i++)
		{
			discards[lastdiscarder] += dis[i] + " ";
		}
		discards[lastdiscarder] = discards[lastdiscarder] + discarded[lastdiscarder].lastElement().taken() + Colors.NORMAL + " ";
		printhand(sender, hostmask);

	}

	public void printdora()
	{
		if (dora == null)
		{
			// error and such
			return;
		}
		String dor = "Dora indicators:";
		for (Tile t : dora)
			dor = dor + " " + t.display;
		sendMessage(channel, dor);
	}

	public void newhand()
	{

		hands = new Vector[4];
		open = new Vector[4];
		discarded = new Vector[4];
		discards = new String[4];
		lastdrawn=new Tile[4];
		wall = Tile.getTiles();// will also shuffle
		dead = new Vector<Tile>();
		dora = new Vector<Tile>();
		for (int i = 0; i < 14; i++)
			dead.add(wall.remove(0));
		dora.add(dead.remove(0));
		for (int i = 0; i < hands.length; i++)
		{
			hands[i] = new Vector<Tile>();
			open[i] = new Vector<Meld>();
			discarded[i] = new Vector<Tile>();
			discards[i] = "";
			for (int j = 0; j < 13; j++)
				hands[i].add(wall.remove(0));

		}
	}

	public void nexthand()
	{
		if (player.size() != 4)
		{
			// TODO error
			return;
		}
		newhand();
		for (String[] s : player)
		{
			printhand(s[0], s[1]);
			printhand(s[0], s[1]);
		}
		printdora();
	}

	public void chi(String sender, String hostmask, String tiles)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			// TODO not in this game
			return;
		}
		if (last == null)
		{
			// TODO can't chi that
			return;
		}
		// TODO check they're in the right possition to chi
		String[] til = tiles.split(",");
		if (til.length != 2)
		{
			// TODO syntax error
			return;
		}
		Tile t1 = Tile.lookup(til[0].toLowerCase().trim());
		Tile t2 = Tile.lookup(til[1].toLowerCase().trim());
		if (t1 == null)
		{
			sendMessage(channel, til[0] + " is not a valid representation for a tile");
			return;
		}
		if (t2 == null)
		{
			sendMessage(channel, til[1] + " is not a valid representation for a tile");
			return;
		}
		if (t1.suit == Tile.HONOR)
		{
			sendMessage(channel, "you cannot chi honor tiles");
			return;
		}
		if (last.suit != t1.suit || last.suit != t2.suit)
		{
			sendMessage(channel, "suits do not match");
		}
		if ((last.number + 1 == t1.number && t1.number + 1 == t2.number) || (last.number + 1 == t2.number && t2.number + 1 == t1.number) || (t1.number + 1 == last.number && last.number + 1 == t2.number) || (t1.number + 1 == t2.number && t2.number + 1 == last.number) || (t2.number + 1 == t1.number && t1.number + 1 == last.number) || (t2.number + 1 == last.number && last.number + 1 == t1.number))
		{
			open[index].add(new Meld(last, new Tile[]
			{ t1, t2 }));
			hands[index].remove(t1);
			hands[index].remove(t2);
			last = null;
			String[] dis = discards[lastdiscarder].split(" ");
			discards[lastdiscarder] = "";
			for (int i = 0; i < dis.length - 1; i++)
			{
				discards[lastdiscarder] += dis[i] + " ";
			}
			discards[lastdiscarder] = discards[lastdiscarder] + discarded[lastdiscarder].lastElement().taken() + Colors.NORMAL + " ";
			printhand(sender, hostmask);
		}
		else
		{
			sendMessage(channel, "invalid chi");
			return;
		}
	}

	public void revealhand(String sender, String hostmask)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			sendMessage(channel, sender + ", you do not have a hand");
			return;
		}
		String hand = hands[index].elementAt(0).display;
		for (int i = 1; i < hands[index].size(); i++)
			hand = hand + " " + hands[index].elementAt(i).display;
		sendMessage(channel, sender + "'s closed:" + hand);
		if (open[index].size() > 0)
		{
			String s = "";
			for (Meld m : open[index])
			{
				s = s + " " + m.taken.taken() + Colors.NORMAL + " ";
				for (Tile t : m.other)
					s = s + t.display + " ";
				s = s + " ";
			}
			sendMessage(channel, sender + "'s open:" + s);
		}
	}

	public void kan(String sender, String hostmask, String tile)
	{
		int index = playerindex(sender, hostmask);
		if (index == -1)
		{
			// TODO not in this game
			return;
		}
		if (tile.trim().equals(""))
		{
			int count = 0;
			for (Tile t : hands[index])
				if (t.equals(last))
					count++;
			if (count < 3)
			{
				sendMessage(channel, sender + ", you cannot kan a " + last.display);
				return;
			}
			open[index].add(new Meld(last, new Tile[]
			{ last, last,last }));
			hands[index].remove(last);
			hands[index].remove(last);
			hands[index].remove(last);
			last = null;
			String[] dis = discards[lastdiscarder].split(" ");
			discards[lastdiscarder] = "";
			for (int i = 0; i < dis.length - 1; i++)
			{
				discards[lastdiscarder] += dis[i] + " ";
			}
			discards[lastdiscarder] = discards[lastdiscarder] + discarded[lastdiscarder].lastElement().taken() + Colors.NORMAL + " ";
			
		}
		else
		{
			Tile t = Tile.lookup(tile.toLowerCase());
			if (t == null)
			{
				sendMessage(channel, tile + " is not a valid representation for a tile");
				return;
			}
			boolean meld=false;
			for(Meld m:open[index])
			{
				if(m.equals(new Meld(t,new Tile[]{t,t}))&&hands[index].contains(t))
				{
					meld=true;
					m.other.add(t);
					hands[index].remove(t);
				}
			}
			if(!meld)
			{
				int count = 0;
				for (Tile tee : hands[index])
					if (tee.equals(t))
						count++;
				if (count < 4)
				{
					sendMessage(channel, sender + ", you cannot kan a " + t.display);
					return;
				}
				open[index].add(new Meld(Tile.nothing, new Tile[]
				{ t, t,t,t }));
				hands[index].remove(t);
				hands[index].remove(t);
				hands[index].remove(t);
				hands[index].remove(t);
			}

		}
		Tile s=dead.remove(0);
		lastdrawn[index]=s;
		hands[index].add(s);
		dead.add(wall.remove(wall.size()-1));
		dora.add(dead.remove(0));
		printhand(sender,hostmask);
		printdora();
	}
	public void uradora()
	{
		 int amount=dora.size();
		 for(int i=0;i < amount;i++)
			 dora.add(dead.remove(0));
		 printdora();
	}

	public void getrecordrequest(String sender, String[] command)
	{
		if(command[1].equalsIgnoreCase("game"))
		{
			
		}
	}
}
