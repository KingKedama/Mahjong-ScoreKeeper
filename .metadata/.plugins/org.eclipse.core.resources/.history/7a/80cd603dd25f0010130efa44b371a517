package mahjong;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;


import org.jibble.pircbot.PircBot;

public class IrcInterface extends PircBot 
{
	
	public static void main(String[] args) {
		//IrcInterface b=new IrcInterface("irc.rizon.net",6667,null,"hakuman","#ddrmtu");
		IrcInterface b=new IrcInterface("irc.rizon.net",6667,null,"hakuman","#ddrmahjong");
		//IrcInterface b=new IrcInterface("irc.foonetic.net",6667,null,"hakuman","#mahjong");
		
		boolean done=false;
		while(!done){
			try{
			b.connect(b.ServerName, b.ServerPort, b.ServerPassword);
			done=true;
			}
			catch(Exception e){}
		}
		done=false;
		while(!done){
			try{
				b.joinChannel(b.channel);
			done=true;
			}
			catch(Exception e){}
		}
		b.sendMessage("nickserv", "identify dancedance");
	}
	public String ServerName;
	public int ServerPort;
	public String ServerPassword;
	public String BotName;
	public String channel;
	public static final String SCORER="ScoreKeeper";
	public Game game;
	
	public int timer=5;
	public ClaimTimeout timeout;
	public Timer time;
	
	public boolean begining;
	
	public IrcInterface(String CServerName, int CServerPort, String CServerPassword, String CBotName, String chan){
		ServerName = CServerName;
		ServerPort = CServerPort;
		ServerPassword = CServerPassword;
		BotName = CBotName;
		this.setName(BotName);
		this.setLogin("KedamaBotsInc");
		time=new Timer();
		channel = chan;
		begining=true;
		BufferedReader in;
		try
		{
			in = new BufferedReader(new FileReader("extraNames"));
		
		String str;
		while ((str = in.readLine()) != null)
		{
			addName(str);
		}
		in.close();
		} catch (Exception e)
		{
		}
		begining=false;
	}
	public void onPrivateMessage(String sender,String login, String hostname, String mess){
		this.onMessage(sender, sender, login, hostname, mess);
	}
	public void onServerResponse(int code, String response){
		Debug.print("%d %s", code,response);
	}
	public void onUnknown(String mess){
		Debug.print("unknown: %s", mess);
	}
	synchronized public void onMessage(String channel, String sender, String login, String hostname, String mess){
		String message=normalize(mess);
		if(message.indexOf('.')==0){ 
			if(message.indexOf("test tiles")==1){
				testtiles();
			}
			else if(message.indexOf("game")==1){
				game(sender);
			}
			else if(message.indexOf("join")==1){
				join(sender);
			}
			else if(message.indexOf("start")==1){
				start();
			}
			else if(message.indexOf("end")==1){
				end();
			}
			else if(message.indexOf("draw")==1){
				schdraw(sender);
			}
			else if(message.indexOf("discard")==1){
				discard(sender,message.substring(8));
			}
			else if(message.indexOf("riichi")==1){
				riichi(sender,message.substring(7));
			}
			else if(message.indexOf("chi")==1){
				schchi(sender,message.substring(4));
			}
			else if(message.indexOf("pon")==1){
				schpon(sender);
			}
			else if(message.indexOf("kan")==1){
				schkan(sender,message.substring(4));
			}
			else if(message.indexOf("ron")==1){
				schron(sender);
			}
			else if(message.indexOf("tsumo")==1){
				tsumo(sender);
			}
			else if(message.indexOf("timeout")==1){
				settimeout(message.substring(8));
			}
			else if(message.indexOf("dora")==1){
				printdora(channel,false);
			}
			else if(message.indexOf("show")==1){
				printhand(sender);
			}
			
		}
	}
	
		
	private void printhand(String sender)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		Player p=game.getplayer(sender);
		if(p==null){
			sendMessage(channel,sender+", you do not have a hand");
			return;
		}
		sendNotice(sender,p.printhand());
		if(!p.open.isEmpty()){
			sendNotice(sender,p.printopen());
		}
		
	}
	public void tsumo(String sender)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(!game.players.get(game.discardturn).name.equalsIgnoreCase(sender)){
			sendMessage(channel,sender+", it is not your turn, you cannot tsumo");
			return;
		}
		if(!game.cantsumo()){
			sendMessage(channel,sender+", you cannot tsumo");
			return;
		}
		
			if(timeout!=null && game.afterkan){
				timeout.tsumo=true;
				return;
			}
			else{
				handScore score=game.tsumo();
				sendMessage(SCORER,"!tsumo irc "+sender+" "+score.hou+" "+score.han);
				Player p=game.getplayer(sender);
				
				sendMessage(channel,p.printhand());
				if(!p.open.isEmpty()){
					sendMessage(channel,p.printopen());
				}
				printdora(channel,p.riichi);
				if(score.yakuman.isEmpty()){
					for(String s:score.yaku){
						sendMessage(channel,s);
					}
				}
				else{
					for(String s:score.yakuman){
						sendMessage(channel,s);
					}
				}
				
				starthand();
			}
	}
		
		
	
	private void printdora(String sender,boolean riichi)
	{
		if(game==null){
			sendMessage(sender,"there is not currently a game");
			return;
		}
		else{
			if(game.doraindicators !=null){
				String s="dora indicators: ";
				for(Tile t:game.doraindicators){
					s+=t.display+" ";
				}
				sendMessage(sender,s);
				if(riichi){
					String d="uradora indicators: ";
					for(Tile t:game.uradora){
						d+=t.display+" ";
					}
					sendMessage(sender,d);
				}
			}
			
		}
		
	}
	private void schron(String sender)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(timeout==null){
			if(game.canron(sender,null)){
				ron(sender);
			}
			else{
				sendMessage(channel,sender+", you cannot ron");
				return;
			}
		}
		else{
			if(game.canron(sender,timeout)){
				timeout.ron.add(sender);
			}
			else{
				sendMessage(channel,sender+", you cannot ron");
				return;
			}
		}
		
	}
	public void ron(String sender)	
	{
		Player p=game.getplayer(sender);
		handScore score=game.ron(sender);
		Player last = game.players.get((game.drawturn + 3) % 4);
		if(game.afterkan){
			last=game.kanner;
		}
		sendMessage(SCORER,"!ron irc "+sender+" "+score.hou+" "+score.han+" "+last.name);
		sendMessage(channel,p.printhand());
		if(p.open.size()>0){
			sendMessage(channel,p.printopen());
		}
		printdora(channel,p.riichi);
		if(score.yakuman.isEmpty()){
			for(String s:score.yaku){
				sendMessage(channel,s);
			}
		}
		else{
			for(String s:score.yakuman){
				sendMessage(channel,s);
			}
		}
		starthand();
		
	}
	private void settimeout(String time)
	{
		try{
			timer=new Integer(time.trim());
			if(timer < 0){
				timer=0;
			}
			sendMessage(channel,"timeout set to "+timer+" seconds");
			
		}
		catch(NumberFormatException e){
			this.sendMessage(channel, time+" is not a number");
		}
	}

	private String normalize(String s){
		/*
		Pattern p=Pattern.compile("(\\w)\\1+");
		Matcher m=p.matcher(s.toLowerCase());
		StringBuffer sb=new StringBuffer();
		while(m.find())
		{
			m.appendReplacement(sb,""+ m.group(0).charAt(0));
		}
		m.appendTail(sb);
		return sb.toString();
		*/
		return s.toLowerCase();
	}
	
	private void testtiles(){
		String tiles = "";
		for (Tile t : Tile.test)
		{
			tiles = tiles + t.display + " ";
		}
		this.sendMessage(channel, tiles);
	}
	
	private void game(String starter){
		if(game !=null){
			sendMessage(channel,"you must end the current game first");
			return;
		}
		game=new Game();
		sendMessage(channel,"starting game, type .join to join");
		join(starter);
	}
	
	private void join(String sender){
		if(game==null){
			game(sender);
			return;
		}
		if(game.players.size()==4){
			sendNotice(sender,"game is already full");
			return;
		}
		for(Player p : game.players){
			if(p.name.equalsIgnoreCase(sender)){
				sendNotice(sender,"you are already in this game");
				return;
			}
		}
		game.players.add(new Player(sender));
		sendMessage(channel,sender+" has joined the game");
	}
	
	private void start(){
		if(game==null){
			sendMessage(channel,"you have to make a game first");
			return;
		}
		if(game.players.size()!=4){
			sendMessage(channel,"not enough players");
			return;
		}
		if(game.inprogress){
			sendMessage(channel,"the game has already started");
			return;
		}
		game.start();
		game.inprogress=true;
		sendMessage(SCORER,"!freeplay irc "+game.players.get(0).name+" "+game.players.get(1).name+" "+game.players.get(2).name+" "+game.players.get(3).name);
		starthand();
		
	}
	public void starthand(){
		game.newhand();
		sendMessage(channel,"Starting hand");
		for(Player p:game.players){
			sendNotice(p.name,p.printhand());
			Tile.sortHand(p.hand);
			sendNotice(p.name,p.printhand());
		}
		printdora(channel,false);
		sendMessage(channel,game.players.get(game.dealer).name+" goes first");
		
	}
	
	private void end(){
		game=null;
		sendMessage(SCORER,"!end irc");
	}
	
	private void schdraw(String sender){
		
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(game.drawturn==-1 || !game.players.get(game.drawturn).name.equalsIgnoreCase(sender)){
			sendMessage(channel,sender+" it is not your turn to draw");
			return;
			
		}
		if(timeout==null){
			draw(sender);
			return;
		}
		timeout.draw=true;
	}
	
	private void schchi(String sender,String tiles)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(game.drawturn==-1 || !game.players.get(game.drawturn).name.equalsIgnoreCase(sender)){
			sendMessage(channel,sender+" you cannot chi a "+game.lastdiscard().display);
			return;
			
		}
		int a=0,b=0;
		String[] split;
		
		
		split=tiles.trim().split(" ");
		for(String s: split){
			Debug.print(s);
		}
		if(split.length ==2){
			try{
				a=new Integer(split[0]);
				b=new Integer(split[1]);
			}
			catch(NumberFormatException e){
				return;
			}
			
		}	
		if(!game.canchi(a,b)){
			sendMessage(channel,sender+" you cannot chi a "+game.lastdiscard().display);
			return;
		}
		if(timeout==null){
			chi(sender,a,b);
			return;
		}
		timeout.chi=true;
		timeout.chiA=a;
		timeout.chiB=b;
	}
	
	private void schpon(String sender){
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(game.drawturn==-1 || game.players.get((game.drawturn +3) % 4) ==game.getplayer(sender)){
			return;
		}
		if(!game.canpon(sender)){
			sendMessage(channel,sender+" you cannot pon a "+game.lastdiscard().display);
			return;
		}
		if(timeout==null){
			pon(sender);
			return;
		}
		timeout.pon=sender;
	}
	private void schkan(String sender, String tile)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(game.players.get(game.discardturn).name.equalsIgnoreCase(sender)){
			closedkan(sender,tile);
			return;
		}
		if(game.drawturn==-1 || game.players.get((game.drawturn +3) % 4) ==game.getplayer(sender)){
			return;
		}
		if(!game.cankan(sender)){
			sendMessage(channel,sender+" you cannot kan a "+game.lastdiscard().display);
			return;
		}
		if(timeout==null){
			kan(sender);
			return;
		}
		timeout.kan=sender;
		
		
	}
	public void kan(String sender)
	{
		sendMessage(channel,sender+" kanned a "+game.lastdiscard().display);
		game.kan(sender);
		Player p=game.getplayer(sender);
		sendNotice(sender,p.printhand());
		sendMessage(channel,sender+"'s visible: "+p.printopen());
		game.afterkan=true;
		game.kanner=p;
		
	}
	private void closedkan(String sender, String tile)
	{
		Player p=game.getplayer(sender);
		if(p.drawn==null){
			sendMessage(channel,sender+", you cannot kan after claiming a tile");
			return;
		}
		Tile t=Tile.lookup(tile.trim());
		if(t==null){
			sendMessage(channel,tile+" is not a valid representation for a tile");
			return;
		}
		Meld openPon=new Meld(false,false,t,t,t);
		if(p.open.contains(openPon)){
			Meld m=p.open.get(p.open.indexOf(openPon));
			Tile q;
			if(p.hand.contains(t)){
				q=p.hand.remove(p.hand.indexOf(t));
			}
			else if(p.drawn.equals(t)){
				q=p.drawn;
				p.drawn=null;
			}
			else{
				sendMessage(channel,sender+", you cannot kan a "+t.display);
				return;
			}
			m.other.add(q);
			m.type=Meld.KAN;
			game.grabablekan=true;
			
		}
		else{
			int count=0;
			for(Tile q:p.hand){
				if(q.equals(t)){
					count++;
				}
			}
			if(p.drawn.equals(t)){
				count++;
			}
			if(count !=4){
				sendMessage(channel,sender+", you cannot kan a "+t.display);
				return;
			}
			if(p.drawn.equals(t)){
				p.open.add(new Meld(true,false,p.drawn,p.hand.remove(p.hand.indexOf(t)),p.hand.remove(p.hand.indexOf(t)),p.hand.remove(p.hand.indexOf(t))));
				p.drawn=null;
			}
			else{
				p.open.add(new Meld(true,false,p.hand.remove(p.hand.indexOf(t)),p.hand.remove(p.hand.indexOf(t)),p.hand.remove(p.hand.indexOf(t)),p.hand.remove(p.hand.indexOf(t))));
			}
			game.grabablekan=false;
		}
		sendMessage(channel,sender+" kanned a "+t.display);
		time.schedule(timeout = new ClaimTimeout(this),timer*1000);
		
		
		game.kanned=t;
		game.afterkan=true;
		game.kanner=p;
		printdora(channel, false);
		sendNotice(sender,game.kandraw(p));
		if(p.open.size() >0){
			sendMessage(channel,sender+"'s open: "+p.printopen());
		}
		
		
		
	}
	public void pon(String sender)
	{
		sendMessage(channel,sender+" pon'd a "+game.lastdiscard().display);
		game.pon(sender);
		Player p=game.getplayer(sender);
		sendNotice(sender,p.printhand());
		sendMessage(channel,sender+"'s visible: "+p.printopen());
		
	}

	public void chi(String sender,int a,int b)
	{
		
		sendMessage(channel,sender+" chied a "+game.lastdiscard().display);
		game.chi(a,b);
		Player p=game.getplayer(sender);
		sendNotice(sender,p.printhand());
		sendMessage(channel,sender+"'s visible "+p.printopen());
		
		
	}

	public void draw(String sender){
		
		sendNotice(sender,game.draw());
		Player p=game.getplayer(sender);
		if(p.open.size() >0){
			sendMessage(channel,sender+"'s visible "+p.printopen());
		}
		sendMessage(channel,""+game.wall.size()+" Tiles left in the wall");
	}
	
	public void discard(String sender, String discard)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(game.discardturn==-1 || !game.players.get(game.discardturn).name.equalsIgnoreCase(sender)){
			sendMessage(channel,sender+" it is not your turn to discard");
			return;
		}
		Tile t=Tile.lookup(discard);
		if(t==null){
			sendMessage(channel,discard+" is not a valid representation for a tile");
			return; 
		}
		if(!game.candiscard(t)){
			sendMessage(channel,sender+", you cannot discard a "+t.display);
			return;
		}
		
		if(timeout!=null && game.afterkan){
			timeout.discard=discard;
			return;
		}
		int next=(game.discardturn+1) % 4;
		sendMessage(channel,sender+"'s discards:"+game.discard(t));
		if(!game.wall.isEmpty()){
			sendMessage(channel,game.players.get(next).name+" is next");
		}
		time.schedule(timeout = new ClaimTimeout(this),timer*1000);
	}
	
	private void riichi(String sender, String discard)
	{
		if(game==null){
			sendMessage(channel,"there is not currently a game");
			return;
		}
		if(game.discardturn==-1 || !game.players.get(game.discardturn).name.equalsIgnoreCase(sender)){
			sendMessage(channel,sender+" it is not your turn to discard");
			return;
		}
		Tile t=Tile.lookup(discard);
		if(t==null){
			sendMessage(channel,discard+" is not a valid representation for a tile");
			return;
		}
		if(!game.canriichi(t)){
			sendMessage(channel,sender+", you cannot riichi on a "+t.display);
			return;
		}
		int next=(game.discardturn+1) % 4;
		sendMessage(channel,sender+"'s discards:"+game.riichi(t));
		sendMessage(SCORER,"!riichi irc "+sender);
		sendMessage(channel,game.players.get(next).name+" is next");
		time.schedule(timeout = new ClaimTimeout(this),timer*1000);
		
	}

	

	class ClaimTimeout extends TimerTask {
		
		public IrcInterface irc;
		
		//after discard
		public List<String> ron;
		public String kan="";
		public String pon="";
		public int chiB;
		public int chiA;
		public boolean chi=false;
		public boolean draw=false;
		
		//after kan, also includes ron
		public String discard="";
		public boolean tsumo;
		
		public ClaimTimeout(IrcInterface i){
			irc=i;
			ron=new ArrayList<String>();
		}
	  public void run() {
		  if(irc.game!=null){
			  irc.game.timeout(irc,this);
		  }
		 irc.timeout=null;
	  }
	}

	
	public void addName(String command)
	{
		Tile t=Tile.lookup(command.split(",")[0]);
		if(t==null)
		{
			sendMessage(channel,command.split(",")[0]+" is not a valid representation for a tile");
			return;
		}
		Tile p=Tile.lookup(command.split(",")[1]);
		if(p!=null)
		{
			sendMessage(channel,command.split(",")[1]+" is already a representation for "+p.display);
			return;
		}
		Tile.addTileName(t, command.split(",")[1]);
		//add to file
		if(!new File("extraNames").exists()){
			File file = new File("extraNames");
			try
			{
				file.createNewFile();
			} catch (IOException e)
			{
				// TODO error
			}
			
		}
		if(!begining)
		try
		{
			BufferedWriter out = new BufferedWriter(new FileWriter("extraNames", true));
			out.write(command+"\n");
			out.close();
		} catch (IOException e)
		{
		}
	}
	
}
