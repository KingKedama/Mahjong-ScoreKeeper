package mahjong;

import java.util.*;

import org.jibble.pircbot.Colors;

import mahjong.IrcInterface.ClaimTimeout;

public class Game
{
	public static int EAST = 0;
	public static int SOUTH = 1;
	public static int WEST = 2;
	public static int NORTH = 3;

	public ArrayList<Tile> wall;
	public ArrayList<Tile> deadwall;
	public ArrayList<Tile> doraindicators;
	public List<Tile> uradora;
	public ArrayList<Player> players;
	public int drawturn = -1;
	public int discardturn = -1;
	public int round = 0;
	public int dealer = 0;
	public boolean afterkan = false;
	public boolean grabablekan = false;
	public Player kanner = null;
	public Tile kanned = null;
	public boolean inprogress = false;

	public Tile lastdiscard()
	{
		if (drawturn != -1)
		{
			Player last = players.get((drawturn + 3) % 4);
			if (last.discard.size() == 0)
			{
				return Tile.nothing;
			}
			return last.discard.get(last.discard.size() - 1);
		}
		else if (discardturn != -1)
		{
			Player last = players.get((discardturn + 3) % 4);
			if (last.discard.size() == 0)
			{
				return Tile.nothing;
			}
			return last.discard.get(last.discard.size() - 1);
		}
		else
		{// if it's no one's turn to draw, and no one's turn to discard, we are
			// in between hands
			return Tile.nothing;
		}
	}

	public Game()
	{
		players = new ArrayList<Player>();

	}

	public void start()
	{
		Collections.shuffle(players);
		newhand();
	}

	public void newhand()
	{
		wall = Tile.getTiles();
		deadwall = new ArrayList<Tile>();
		doraindicators = new ArrayList<Tile>();
		uradora=new ArrayList<Tile>();
		for (int i = 0; i < 14; i++)
		{
			deadwall.add(wall.remove(0));
		}
		doraindicators.add(deadwall.remove(0));
		for (Player p : players)
		{
			p.newhand();
			for (int i = 0; i < 13; i++)
			{
				p.hand.add(wall.remove(0));
			}
		}
		drawturn = dealer;

	}

	public String draw()
	{
		for (Player p : players)
		{
			p.furitendiscard.add(lastdiscard());
		}
		Player p = players.get(drawturn);
		p.drawn = wall.remove(0);
		if (!p.riichi)
		{
			p.furitendiscard.clear();
		}
		discardturn = drawturn;
		String s = players.get(drawturn).printhand();
		drawturn = -1;
		return s;

	}

	public void timeout(IrcInterface i, ClaimTimeout state)
	{
		if(state.ron.size()==3){
			//TODO draw
		}
		else if(state.ron.size()==2){
			i.doubleron(state.ron.get(0),state.ron.get(1));
		}
		else if (state.ron.size() == 1)
		{
			i.ron(state.ron.get(0));
			return;
		}
		else if (state.discard.length() > 0)
		{
			i.discard(players.get(discardturn).name, state.discard);
			return;
		}
		else if (afterkan && state.tsumo)
		{
			i.tsumo(players.get(discardturn).name);
			return;
		}
		else if (state.kan.length() > 0)
		{
			i.kan(state.kan);
			return;
		}
		else if (state.pon.length() > 0)
		{
			i.pon(state.pon);
			return;
		}
		else if (state.chi)
		{
			i.chi(players.get(drawturn).name, state.chiA, state.chiB);
			return;
		}

		else if (drawturn != -1 && wall.size() == 0)
		{
			String s = "!tenpai irc ";
			boolean change = true;
			for (Player p : players)
			{
				if (!tenpai(p.hand, p.open).isEmpty())
				{
					s += p.name + " ";
					if (getPos(p) == dealer)
					{
						change = false;
					}
				}
			}
			s = s.trim();
			i.sendMessage(i.SCORER, s);
			if (change)
			{
				dealer = (dealer + 1) % 4;
				if (dealer == 0)
				{
					round++;
				}
			}
			i.starthand();
			return;
		}
		else if (state.draw)
		{
			i.draw(players.get(drawturn).name);
			return;
		}

	}

	public String discard(Tile t)
	{
		Player p = players.get(discardturn);
		if (p.hand.contains(t))
		{
			p.discard.add(p.hand.remove(p.hand.indexOf(t)));
			if (p.drawn != null)
			{

				p.hand.add(p.drawn);
				Tile.sortHand(p.hand);
				p.drawn = null;
			}
		}
		else if (p.drawn.equals(t))
		{
			p.discard.add(p.drawn);
			p.drawn = null;
		}
		if (p.ippatsu)
		{
			p.ippatsu = false;
		}
		drawturn = (discardturn + 1) % 4;
		discardturn = -1;
		afterkan = false;
		grabablekan = false;
		kanned = null;
		return p.printdiscard();

	}

	public boolean candiscard(Tile t)
	{
		// TODO prevent discarding same tile gained through whatever
		// stuff
		if (discardturn == -1)
		{
			return false;
		}
		Player p = players.get(discardturn);
		if (p.riichi)
		{
			if (p.drawn.equals(t))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else if (p.hand.contains(t) || p.drawn.equals(t))
		{
			return true;
		}
		return false;
	}

	public static List<Tile> tenpai(List<Tile> h, ArrayList<Meld> m)
	{
		List<Tile> waits = new ArrayList<Tile>();
		for (Tile t : Tile.test)
		{
			// Debug.print("testing tile %s",
			// Colors.removeFormattingAndColors(t.display));
			LinkedList<Tile> hand = new LinkedList<Tile>();
			hand.addAll(h);
			// hand.addFirst(t);
			if (findMelds(m, hand, t, false, 0, 0, true).value > handScore.noten.value)
			{
				waits.add(t);
			}
		}
		return waits;
	}

	public static handScore findMelds(ArrayList<Meld> melds, LinkedList<Tile> hand, Tile win, boolean tsumo, int round, int seat, boolean tenpai)
	{
		handScore max = handScore.noten;
		if (hand.isEmpty() && win == null)
		{ // hand is complete or nothing
			return findYaku(melds, tsumo, round, seat, tenpai);

		}
		if (melds.isEmpty())
		{// check for 13 orphans
			boolean orphans = true;
			int ends = 0;
			for (Tile t : Tile.ends)
			{
				if (!hand.contains(t) && !t.equals(win))
				{
					orphans = false;
					break;
				}
				else
				{
					ends++;
				}
			}
			for (Tile t : hand)
			{
				if (!Tile.ends.contains(t))
				{
					orphans = false;
					break;
				}
			}
			if (win != null && !Tile.ends.contains(win))
			{
				orphans = false;
			}
			if (orphans)
			{
				handScore score = new handScore(0, -1);
				if (hand.contains(win))
				{
					score.han = -2;
					score.yakuman.add(handScore.formatyakuman("13 orphans", 2));
					score.recalculate();
					return score;
				}
				else
				{
					score.yakuman.add(handScore.formatyakuman("13 orphans", 1));
					score.recalculate();
					return score;
				}
			}
		}
		Tile t;
		boolean haswin = false, closed = true;
		if (win != null)
		{
			t = win;
			haswin = true;
			closed = tsumo;
			win = null;
		}
		else
		{
			t = hand.removeFirst();
		}
		// try pair
		int pairs = Meld.paircount(melds);
		if (pairs == 0 || pairs == melds.size())
		{ // hand could use a pair
			if (hand.contains(t))
			{
				LinkedList<Tile> htmp = new LinkedList<Tile>();
				htmp.addAll(hand);
				ArrayList<Meld> mtmp = new ArrayList<Meld>();
				mtmp.addAll(melds);
				mtmp.add(new Meld(closed, haswin, t, htmp.remove(htmp.indexOf(t))));
				handScore value = findMelds(mtmp, htmp, win, tsumo, round, seat, tenpai);
				if (value.value > max.value)
				{
					max = value;
				}
				else if (value.value == max.value)
				{
					if (value.han > max.han)
					{
						max = value;
					}
					else if (value.han == max.han && value.hou > max.hou)
					{
						max = value;
					}

				}
			}
		}
		if (pairs > 1)
		{ // this must already be a 7 pairs hand, shouldn't try non-pair melds
			return max;
		}
		// try pon
		if (hand.contains(t))
		{ // only way to pon
			LinkedList<Tile> htmp = new LinkedList<Tile>();
			htmp.addAll(hand);
			htmp.remove(t);
			if (htmp.contains(t))
			{ // third
				ArrayList<Meld> mtmp = new ArrayList<Meld>();
				mtmp.addAll(melds);
				mtmp.add(new Meld(closed, haswin, t, t, t));
				LinkedList<Tile> secondhtmp = new LinkedList<Tile>();
				secondhtmp.addAll(htmp);
				secondhtmp.remove(secondhtmp.indexOf(t));
				handScore value = findMelds(mtmp, secondhtmp, win, tsumo, round, seat, tenpai);
				if (value.value > max.value)
				{
					max = value;
				}
				else if (value.value == max.value)
				{
					if (value.han > max.han)
					{
						max = value;
					}
					else if (value.han == max.han && value.hou > max.hou)
					{
						max = value;
					}

				}
			}
		}
		// try chi
		HashSet<Tile> tried = new HashSet<Tile>();
		for (Tile s : hand)
		{
			if (!tried.contains(s))
			{
				tried.add(s);
				ArrayList<Tile> possibles = Tile.sequenceWith(t, s);
				LinkedList<Tile> htmp = new LinkedList<Tile>();
				htmp.addAll(hand);
				htmp.remove(s);
				for (Tile u : possibles)
				{
					if (htmp.contains(u))
					{
						tried.add(u);
						ArrayList<Meld> mtmp = new ArrayList<Meld>();
						mtmp.addAll(melds);
						LinkedList<Tile> secondhtmp = new LinkedList<Tile>();
						secondhtmp.addAll(htmp);
						secondhtmp.remove(u);
						mtmp.add(new Meld(closed, haswin, t, u, s));
						handScore value = findMelds(mtmp, secondhtmp, win, tsumo, round, seat, tenpai);
						if (value.value > max.value)
						{
							max = value;
						}
						else if (value.value == max.value)
						{
							if (value.han > max.han)
							{
								max = value;
							}
							else if (value.han == max.han && value.hou > max.hou)
							{
								max = value;
							}
						}
					}
				}
			}
		}

		return max;
	}

	private static handScore findYaku(ArrayList<Meld> melds, boolean tsumo, int round, int seat, boolean tenpai)
	{

		int hou = hou(melds, round, seat);
		handScore score = new handScore(hou, 2);
		boolean closed = true;

		List<Meld> pairs = new ArrayList<Meld>();
		List<Meld> sequences = new ArrayList<Meld>();
		List<Tile> triads = new ArrayList<Tile>();
		int quads = 0;
		int concealedTriads = 0;
		int concealedQuads = 0;
		int yakumans = 0;
		boolean dragonpair = false;
		boolean windpair = false;
		boolean terminals = false;
		boolean honors = false;
		boolean nonend = false;
		boolean man = false;
		boolean sou = false;
		boolean pin = false;
		boolean notgreen = false;
		int[] numbers = new int[]
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		for (Meld m : melds)
		{
			if (m.taken.suit == Tile.HONOR)
			{
				honors = true;
			}
			else
			{

				if (m.taken.number == 9 || m.taken.number == 1 || m.other.contains(Tile.lookup(m.taken.suit, 1)) || m.other.contains(Tile.lookup(m.taken.suit, 9)))
				{
					terminals = true;
				}
				else
				{
					nonend = true;
				}
				if (m.taken.suit == Tile.PIN)
				{
					pin = true;
				}
				if (m.taken.suit == Tile.MAN)
				{
					man = true;
				}
				if (m.taken.suit == Tile.SOU)
				{
					sou = true;
				}
				numbers[m.taken.number - 1]++;
				for (Tile t : m.other)
				{
					numbers[t.number - 1]++;
				}
			}

			if (!(Tile.green.contains(m.taken) && Tile.green.containsAll(m.other)))
			{
				notgreen = true;
			}
			if (!m.closed && !m.win)
			{
				closed = false;
			}
			if (m.type == Meld.PAIR)
			{
				if (pairs.contains(m))
				{
					return handScore.noten;
				}
				else
				{

					pairs.add(m);
					if (m.taken.suit == Tile.HONOR)
					{
						if (m.taken.number < 4)
						{
							windpair = true;
						}
						else
						{
							dragonpair = true;
						}
					}
				}
			}
			else if (m.type == Meld.CHI)
			{
				sequences.add(m);
			}
			else if (m.type == Meld.PON)
			{
				triads.add(m.taken);
				if (m.closed)
				{
					concealedTriads++;
				}
			}
			else if (m.type == Meld.KAN)
			{
				triads.add(m.taken);
				quads++;
				if (m.closed)
				{
					concealedTriads++;
					concealedQuads++;
				}
			}
		}
		if (tenpai)
		{// if this is for tenpai detection only
			return new handScore(20, 2);
		}
		boolean pinfu = false;
		if (hou == 20 && closed)
		{
			score.yaku.add(handScore.formatyaku("Pinfu", 1));
			score.han++;
			pinfu = true;
		}
		if (tsumo && closed)
		{
			score.yaku.add(handScore.formatyaku("Strongly Closed", 1));
			score.han++;
		}
		if (tsumo && !pinfu)
		{
			score.hou += 2;
		}
		else if (!tsumo && closed)
		{
			score.hou += 10;
		}
		if (score.hou % 10 != 0)
		{
			score.hou = score.hou + 10 - (score.hou % 10);
		}
		if (pairs.size() == 7)
		{
			score.hou = 25;
			score.han += 2;
			score.yaku.add(handScore.formatyaku("7 pairs", 2));
		}
		int sistersequences = 0;
		for (int i = 0; i < sequences.size(); i++)
		{
			for (int j = i + 1; j < sequences.size(); j++)
			{
				if (sequences.get(i).equals(sequences.get(j)))
				{
					sistersequences++;
				}
			}
		}
		if (sistersequences == 1 && closed)
		{
			score.han++;
			score.yaku.add(handScore.formatyaku("Sister Sequence", 1));
		}
		else if (sistersequences == 2 && closed)
		{// double sister sequence
			score.han += 3;
			score.yaku.add(handScore.formatyaku("Double Sister Sequence", 3));
		}
		else if (sistersequences == 3 && closed)
		{// not sure how we're scoring this one, 3 identical sequences,
			// currently one sister sequence
			score.han++;
			score.yaku.add(handScore.formatyaku("Sister Sequence", 1));
		}
		else if (sistersequences == 6 && closed)
		{// 4 identical sequences, just double sister sequence currently
			score.han += 3;
			score.yaku.add(handScore.formatyaku("Double Sister Sequence", 3));
		}
		if (sequences.size() > 2)
		{
			if (sequences.contains(Meld.oneBreathMan123) && sequences.contains(Meld.oneBreathMan456) && sequences.contains(Meld.oneBreathMan789) || sequences.contains(Meld.oneBreathPin123) && sequences.contains(Meld.oneBreathPin456) && sequences.contains(Meld.oneBreathPin789) || sequences.contains(Meld.oneBreathSou123) && sequences.contains(Meld.oneBreathSou456) && sequences.contains(Meld.oneBreathSou789))
			{
				int han;
				if (closed)
					han = 2;
				else
					han = 1;
				score.han += han;
				score.yaku.add(handScore.formatyaku("One Breath", han));
			}
			else
			{
				for (Meld m : sequences)
				{
					Tile atmp0 = Tile.lookup((m.taken.suit + 1) % 3, m.taken.number);
					Tile atmp1 = Tile.lookup((m.taken.suit + 1) % 3, m.other.get(0).number);
					Tile atmp2 = Tile.lookup((m.taken.suit + 1) % 3, m.other.get(1).number);
					if (sequences.contains(new Meld(false, false, atmp0, atmp1, atmp2)))
					{
						Tile btmp0 = Tile.lookup((m.taken.suit + 2) % 3, m.taken.number);
						Tile btmp1 = Tile.lookup((m.taken.suit + 2) % 3, m.other.get(0).number);
						Tile btmp2 = Tile.lookup((m.taken.suit + 2) % 3, m.other.get(1).number);
						if (sequences.contains(new Meld(false, false, btmp0, btmp1, btmp2)))
						{
							int han;
							if (closed)
								han = 2;
							else
								han = 1;
							score.han += han;
							score.yaku.add(handScore.formatyaku("same sequence three suit", han));
							break;
						}
					}
				}
			}
		}
		if (triads.size() == 4)
		{
			score.han += 2;
			score.yaku.add(handScore.formatyaku("Toitoi", 2));
			if (quads == 4)
			{
				yakumans++;
				score.yakuman.add(handScore.formatyakuman("four kans", 1));
			}
		}
		if (concealedTriads == 4)
		{
			if (pairs.get(0).win)
			{
				yakumans += 2;
				score.yaku.add(handScore.formatyakuman("four concealed triads", 2));
			}
			else
			{
				yakumans++;
				score.yakuman.add(handScore.formatyakuman("four concealed triads", 1));
			}
		}
		if (concealedTriads == 3)
		{
			score.han += 2;
			score.yaku.add(handScore.formatyaku("three concealed triads", 2));
		}
		if (quads == 3)
		{
			score.han += 2;
			score.yaku.add(handScore.formatyaku("three kans", 2));
		}
		boolean sametriad = false;
		boolean threeconsecutive = false;
		int dragons = 0;
		int winds = 0;
		for (Tile t : triads)
		{
			if (t.suit < 3 && !sametriad)
			{// not an honor
				if (triads.contains(Tile.lookup((t.suit + 1) % 3, t.number)) && triads.contains(Tile.lookup((t.suit + 2) % 3, t.number)))
				{
					score.han += 2;
					score.yaku.add(handScore.formatyaku("same triad each suit", 2));
					sametriad = true;
				}
			}
			if (triads.contains(Tile.lookup(t.suit, t.number + 1)) && triads.contains(Tile.lookup(t.suit, t.number + 2)))
			{
				if (!threeconsecutive)
				{
					score.han += 2;
					score.yaku.add(handScore.formatyaku("three consecutive triads", 2));
					threeconsecutive = true;
				}
				else
				{// means there are four consecutive triads,currently
					// nothing special
				}
			}
			if (t.suit == Tile.HONOR)
			{
				if (t.number < 4)
				{
					winds++;
					if (t.number == round)
					{
						score.han++;
						score.yaku.add(handScore.formatyaku(t.display + ": round wind", 1));
					}
					if (t.number == seat)
					{
						score.han++;
						score.yaku.add(handScore.formatyaku(t.display + ": seat wind", 1));
					}
				}
				else
				{
					dragons++;
					score.han++;
					score.yaku.add(handScore.formatyaku(t.display, 1));
				}
			}
		}
		if (dragons == 3)
		{
			yakumans++;
			score.yakuman.add(handScore.formatyakuman("big three dragons", 1));
		}
		else if (dragons == 2 && dragonpair)
		{
			score.han += 2;
			score.yaku.add(handScore.formatyaku("little three dragons", 2));
		}
		if (winds == 4)
		{
			yakumans += 2;
			score.yakuman.add(handScore.formatyakuman("big four joys", 2));
		}
		else if (winds == 3 && windpair)
		{
			yakumans += 1;
			score.yakuman.add(handScore.formatyakuman("little four joys", 1));
		}

		if (closed && !terminals && !honors)
		{
			score.han++;
			score.yaku.add(handScore.formatyaku("endless", 1));
		}
		if (!nonend)
		{
			if (terminals && honors && !sequences.isEmpty())
			{
				int han = 1;
				if (closed)
				{
					han++;
				}
				score.han += han;
				score.yaku.add(handScore.formatyaku("dirty termfull", han));
			}
			else if (terminals && !sequences.isEmpty())
			{
				int han = 2;
				if (closed)
				{
					han++;
				}
				score.han += han;
				score.yaku.add(handScore.formatyaku("termfull", han));
			}
			else if (terminals && honors)
			{
				score.han += 2;
				score.yaku.add(handScore.formatyaku("dirty terminals", 2));
			}
			else if (terminals)
			{
				yakumans++;
				score.yakuman.add(handScore.formatyakuman("pure terminals", 1));
			}
			else if (honors)
			{
				yakumans++;
				score.yakuman.add(handScore.formatyakuman("pure honors", 1));
			}
		}
		if ((pin && !sou && !man) || (sou && !pin && !man) || (man && !sou && !pin))
		{
			int han = 2;
			if (closed)
			{
				han++;
			}
			if (honors)
			{
				score.han += han;
				score.yaku.add(handScore.formatyaku("dirty one suit", han));
			}
			else
			{
				han += 3;
				score.han += han;
				score.yaku.add(handScore.formatyaku("pure one suit", han));
				boolean ninegates = true;
				boolean chariot = true;
				int extra = -1;
				for (int i = 0; i < 9; i++)
				{
					if (i == 0 || i == 8)
					{
						if (numbers[i] > 0)
						{
							chariot = false;
							if (numbers[i] == 4)
							{
								extra = i + 1;
							}
							else if (numbers[i] != 3)
							{
								ninegates = false;
							}
						}
						else
						{
							ninegates = false;
						}
					}
					else
					{
						if (numbers[i] == 2)
						{
							extra = i + 1;
						}
						else
						{
							chariot = false;
							if (numbers[i] != 1)
							{
								ninegates = false;
							}
						}
					}
				}
				if (ninegates && closed)
				{
					int y = 1;

					if (extra == melds.get(0).taken.number)
					{
						y++;
					}
					score.yakuman.add(handScore.formatyakuman("Nine Gates", y));
					yakumans += y;
				}
				if (chariot && closed)
				{
					score.yakuman.add(handScore.formatyakuman("Chariot", 1));
					yakumans++;
				}
			}

			if (!notgreen)
			{
				yakumans++;
				score.yakuman.add(handScore.formatyakuman("All Green", 1));
			}
		}

		if (yakumans == 1)
		{
			score.han = handScore.YAKUMAN;

		}
		else if (yakumans > 1)
		{
			score.han = handScore.DOUBLEYAKUMAN;
		}
		score.recalculate();
		return score;
	}

	public boolean canriichi(Tile t)
	{

		if (discardturn == -1)
		{
			return false;
		}
		Player p = players.get(discardturn);
		if (!p.open.isEmpty())
		{
			return false;
		}
		if(wall.size()<4){
			return false;
		}
		if (p.hand.contains(t))
		{
			List<Tile> hand = new LinkedList<Tile>();
			hand.addAll(p.hand);
			hand.remove(t);
			hand.add(p.drawn);
			if (tenpai(hand, p.open).size() > 0)
			{
				return true;
			}
		}
		else if (p.drawn.equals(t))
		{
			if (tenpai(p.hand, p.open).size() > 0)
			{
				return true;
			}
		}
		return false;
	}

	public String riichi(Tile t)
	{
		Player p = players.get(discardturn);
		p.riichi = true;
		p.riichitile = p.discard.size();
		String s = discard(t);
		p.ippatsu = true;
		return s;
	}

	public boolean canchi(int a, int b)
	{
		Tile t = lastdiscard();
		if (drawturn == -1)
		{// shouldn't happen
			return false;
		}
		if(wall.size()==0){
			return false;
		}
		Player p = players.get(drawturn);
		if (a == 0 || b == 0)
		{
			for (Tile s : p.hand)
			{
				for (Tile u : Tile.sequenceWith(t, s))
				{
					if (p.hand.contains(u))
					{
						return true;
					}
				}
			}
		}
		else
		{
			if (Tile.sequenceWith(t, Tile.lookup(t.suit, a)).contains(Tile.lookup(t.suit, b)))
			{
				return true;
			}
		}

		return false;
	}

	public void chi(int a, int b)
	{
		System.out.println("" + a + " " + b);
		Player p = players.get(drawturn);
		if (a != 0 && b != 0)
		{

			Tile t = Tile.lookup(lastdiscard().suit, a);
			Tile s = Tile.lookup(lastdiscard().suit, b);
			Debug.print(t.display);
			Debug.print(s.display);
			p.open.add(new Meld(false, false, lastdiscard(), t, s));
			p.hand.remove(t);
			p.hand.remove(s);
			Player last = players.get((drawturn + 3) % 4);
			last.claimed.add(last.discard.size() - 1);
		}
		else
		{
			boolean done = false;
			Tile one = Tile.nothing;
			Tile two = Tile.nothing;
			for (Tile t : p.hand)
			{
				List<Tile> poss = Tile.sequenceWith(t, lastdiscard());
				for (Tile s : poss)
				{
					if (p.hand.contains(s) & !done)
					{
						p.open.add(new Meld(false, false, lastdiscard(), t, s));
						one = t;
						two = s;
						Player last = players.get((drawturn + 3) % 4);
						last.claimed.add(last.discard.size() - 1);
						done = true;
					}
				}
			}
			p.hand.remove(one);
			p.hand.remove(two);
		}
		for (Player x : players)
		{
			x.ippatsu = false;
			if (!x.riichi)
			{
				x.furitendiscard.clear();
			}
		}
		discardturn = drawturn;
		drawturn = -1;
		// TODO set nondiscardable tiles
	}

	public Player getplayer(String sender)
	{
		for (Player p : players)
		{
			if (p.name.equalsIgnoreCase(sender))
			{
				return p;
			}
		}
		return null;
	}

	public int getPos(Player p)
	{

		for (int i = 0; i < players.size(); i++)
		{
			if (players.get(i).equals(p))
			{
				return i;
			}
		}
		return -1;
	}

	public boolean canpon(String sender)
	{
		if(wall.size()==0){
			return false;
		}
		Player p = getplayer(sender);
		Tile t = lastdiscard();
		int count = 0;
		for (Tile s : p.hand)
		{
			if (s.equals(t))
			{
				count++;
			}
		}
		if (count >= 2)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	public void pon(String sender)
	{
		Player p = getplayer(sender);
		Tile t = lastdiscard();
		p.open.add(new Meld(false, false, t, p.hand.remove(p.hand.indexOf(t)), p.hand.remove(p.hand.indexOf(t))));
		Player last = players.get((drawturn + 3) % 4);
		last.claimed.add(last.discard.size() - 1);
		discardturn = getPos(p);
		drawturn = -1;
		for (Player x : players)
		{
			x.ippatsu = false;
			if (!x.riichi)
			{
				x.furitendiscard.clear();
			}
		}
	}

	public static int hou(List<Meld> melds, int round, int seat)
	{
		int hou = 20;
		for (Meld m : melds)
		{
			if (m.type == Meld.CHI && m.win)
			{
				if (Tile.sequenceWith(m.other.get(0), m.other.get(1)).size() == 1)
				{
					hou += 2;// one sidded wait
				}
			}
			if (m.type == Meld.PAIR)
			{
				if (m.win)
				{
					hou += 2;
				}
				if (m.taken.suit == Tile.HONOR)
				{
					if (m.taken.number == Tile.haku.number || m.taken.number == Tile.hatsu.number || m.taken.number == Tile.chun.number || m.taken.number == round)
					{
						hou += 2;
					}
					if (m.taken.number == seat)
					{
						hou += 2;
					}
				}
			}
			if (m.type == Meld.PON || m.type == Meld.KAN)
			{
				int h = 2;
				if (m.closed)
				{
					h *= 2;
				}
				if (Tile.ends.contains(m.taken))
				{
					h *= 2;
				}
				if (m.type == Meld.KAN)
				{
					h *= 4;
				}
				hou += h;
			}
		}

		return hou;
	}

	public String kandraw(Player p)
	{
		p.drawn = deadwall.remove(0);
		if (!p.riichi)
		{
			p.furitendiscard.clear();
		}
		String s = p.printhand();
		discardturn = getPos(p);
		drawturn = -1;
		doraindicators.add(deadwall.remove(0));
		if(!wall.isEmpty()){
			deadwall.add(wall.remove(0));
		}
		return s;
	}

	public boolean cankan(String sender)
	{
		if(wall.size()==0){
			return false;
		}
		Player p = getplayer(sender);
		Tile t = lastdiscard();
		int count = 0;
		for (Tile s : p.hand)
		{
			if (s.equals(t))
			{
				count++;
			}
		}
		if (count == 3)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	public void kan(String sender)
	{
		Player p = getplayer(sender);
		Tile t = lastdiscard();
		p.open.add(new Meld(false, false, t, p.hand.remove(p.hand.indexOf(t)), p.hand.remove(p.hand.indexOf(t)), p.hand.remove(p.hand.indexOf(t))));
		Player last = players.get((drawturn + 3) % 4);
		last.claimed.add(last.discard.size() - 1);
		discardturn = getPos(p);
		drawturn = -1;
		for (Player x : players)
		{
			x.ippatsu = false;
			if (!x.riichi)
			{
				x.furitendiscard.clear();
			}
		}
		doraindicators.add(deadwall.remove(0));
		if(!wall.isEmpty()){
			deadwall.add(wall.remove(0));
		}
	}

	public boolean canron(String sender, ClaimTimeout timeout)
	{
		Player p = getplayer(sender);
		int pos = getPos(p);
		pos = (pos - dealer + 4) % 4;
		for (Tile t : tenpai(p.hand, p.open))
		{
			if (p.discard.contains(t) || p.furitendiscard.contains(t))
			{
				return false;
			}
		}

		if (timeout == null)
		{
			handScore score = findMelds(p.open, p.hand, lastdiscard(), false, round, pos, false);
			chancemultipliers(p, score, afterkan);
			if (score.han > 2 || score.han < 0)
			{
				return true;
			}

		}
		else
		{
			if (afterkan && grabablekan)
			{

				handScore score = findMelds(p.open, p.hand, kanned, false, round, pos, false);
				chancemultipliers(p, score, afterkan);
				if (score.han > 2 || score.han < 0)
				{
					return true;
				}// TODO add 13 orphans exception
			}
			else
			{
				handScore score = findMelds(p.open, p.hand, lastdiscard(), false, round, pos, false);
				chancemultipliers(p, score, afterkan);
				if (score.han > 2 || score.han < 0)
				{

					return true;
				}
			}
		}
		return false;
	}

	public handScore ron(String sender)
	{
		Player p = getplayer(sender);
		int pos = getPos(p);
		pos = (pos - dealer + 4) % 4;
		handScore score;

		if (afterkan)
		{
			score = findMelds(p.open, p.hand, kanned, false, round, pos, false);

		}
		else
		{
			score = findMelds(p.open, p.hand, lastdiscard(), false, round, pos, false);
		}
		chancemultipliers(p, score, afterkan);
		doracount(p,score);
		if (getPos(p) != dealer)
		{
			dealer = (dealer + 1) % 4;
			if (dealer == 0)
			{
				round = round + 1;
			}
		}
		return score;
	}

	public boolean cantsumo()
	{
		Player p = players.get(discardturn);
		int pos = getPos(p);
		pos = (pos - dealer + 4) % 4;
		handScore score = findMelds(p.open, p.hand, p.drawn, true, round, pos, false);
		chancemultipliers(p, score, afterkan);
		if (score.han > 2)
		{
			return true;
		}
		else
		{
			return false;
		}

	}

	private void chancemultipliers(Player p, handScore s, boolean afterkan)
	{
		if (p.riichi)
		{
			if (p.riichitile == 0)
			{
				s.yaku.add(handScore.formatyaku("double riichi", 1));
				s.han += 2;
			}
			else
			{
				s.yaku.add(handScore.formatyaku("riichi", 1));
				s.han++;
			}

			if (p.ippatsu)
			{
				s.yaku.add(handScore.formatyaku("ippatsu", 1));
				s.han++;
			}
		}
		if (wall.size() == 0)
		{
			if (players.get(discardturn) == p)
			{
				s.yaku.add(handScore.formatyaku("scooping the moon", 1));
				s.han++;
			}
			else
			{
				s.yaku.add(handScore.formatyaku("scooping the fish", 1));
				s.han++;
			}

		}
		if (afterkan)
		{
			if (players.get(discardturn) == p)
			{
				s.yaku.add(handScore.formatyaku("scooping the flower", 1));
				s.han++;
			}
			else
			{
				s.yaku.add(handScore.formatyaku("kan rob", 1));
			}
		}

	}

	public handScore tsumo()
	{
		Player p = players.get(discardturn);
		int pos = getPos(p);
		pos = (pos - dealer + 4) % 4;
		handScore score;
		score = findMelds(p.open, p.hand, p.drawn, true, round, pos, false);
		chancemultipliers(p, score, afterkan);
		doracount(p,score);
		
		if (getPos(p) != dealer)
		{
			dealer = (dealer + 1) % 4;
			if (dealer == 0)
			{
				round = round + 1;
			}
		}
		return score;
	}
	
	private List<Tile> getdora(boolean riichi)
	{
		List<Tile> dora=new ArrayList<Tile>();
		for(Tile t:doraindicators){
			dora.add(t.next());
		}
		if(riichi){
			for(Tile t:uradora){
				dora.add(t.next());
			}
		}
		
		return dora;
	}
	public void doracount(Player p,handScore score){
		if(p.riichi && uradora.isEmpty()){
			for(Tile t: doraindicators){
				uradora.add(deadwall.remove(0));
			}
		}
		List<Tile> doratiles=getdora(p.riichi);
		int dora=0;
		for(Tile t:p.hand){
			if(doratiles.contains(t)){
				dora++;
			}
		}
		if(doratiles.contains(p.drawn)){
			dora++;
		}
		for(Meld m:p.open){
			if(doratiles.contains(m.taken)){
				dora++;
			}
			for(Tile t:m.other){
				if(doratiles.contains(t)){
					dora++;
				}
			}
		}
		if(dora > 0){
			score.han+=dora;
			score.yaku.add(handScore.formatyaku("dora", dora));
		}
	}
}
